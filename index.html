<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Î∏îÎ°ù Î∏îÎûòÏä§Ìä∏ ÏÜîÎ≤Ñ</title>
  <!-- Use Tailwind via CDN for rapid styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" rel="stylesheet" />
  <style>
    /* Custom Styles to replace missing styles.css */
    body {
      font-family: 'Inter', sans-serif;
    }

    /* Utility to hide scrollbars */
    .scrollbar-hide::-webkit-scrollbar {
      display: none;
    }

    .scrollbar-hide {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    /* Glassmorphism utilities */
    .glass {
      background: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
  </style>
</head>

<body class="bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 min-h-screen text-slate-800">

  <!-- Navigation (Simplified) -->
  <nav class="w-full py-4 px-6 flex justify-between items-center max-w-7xl mx-auto">
    <div class="flex items-center gap-2">
      <!-- Simple Logo Placeholder -->
      <div class="h-8 w-8 bg-indigo-600 rounded-lg flex items-center justify-center text-white font-bold">B</div>
      <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-indigo-600 to-purple-600">Î∏îÎ°ù Î∏îÎûòÏä§Ìä∏
        ÏÜîÎ≤Ñ</h1>
    </div>
  </nav>

  <!-- Main Content -->
  <main class="max-w-3xl mx-auto px-4 py-8 flex flex-col items-center gap-6">

    <!-- Upload Section -->
    <div class="text-center mb-6">
      <h2 class="text-4xl font-extrabold mb-4 text-slate-900">Ïä§ÌÅ¨Î¶∞ÏÉ∑ ÏóÖÎ°úÎìú</h2>
      <p class="text-gray-500">Í≤åÏûÑ ÌôîÎ©¥ÏùÑ ÏóÖÎ°úÎìúÌïòÎ©¥ ÏµúÏ†ÅÏùò Ï†ÑÎûµÏùÑ ÏïåÎ†§ÎìúÎ¶ΩÎãàÎã§.</p>
    </div>

    <!-- App Container -->
    <div
      class="w-full bg-white/80 backdrop-blur-xl rounded-3xl shadow-2xl border border-white/50 overflow-hidden relative">

      <!-- 1. Input Area -->
      <div class="p-6 md:p-10 space-y-8">

        <!-- Upload / Preview Box -->
        <div id="upload-wrapper" class="relative group w-full max-w-sm mx-auto aspect-[3/5]">
          <!-- File Input Overlay -->
          <label for="image-upload" class="cursor-pointer block w-full h-full relative z-10">
            <div id="upload-placeholder"
              class="w-full h-full rounded-2xl border-2 border-dashed border-indigo-200 bg-indigo-50/50 flex flex-col items-center justify-center hover:bg-indigo-50 transition-colors">
              <svg class="w-10 h-10 text-indigo-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                </path>
              </svg>
              <span class="text-sm font-medium text-indigo-600">ÌÉ≠ÌïòÏó¨ ÏóÖÎ°úÎìú</span>
            </div>
            <img id="preview-img"
              class="absolute inset-0 w-full h-full object-contain bg-black/5 rounded-2xl hidden shadow-lg" />
          </label>
          <input id="image-upload" type="file" class="hidden" accept="image/*" />

          <!-- Loading Overlay -->
          <div id="loading-overlay"
            class="hidden absolute inset-0 bg-white/80 backdrop-blur-sm z-20 rounded-2xl flex items-center justify-center">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
          </div>
        </div>

        <!-- Analysis Results (Hidden by default) -->
        <div id="analysis-results" class="hidden animate__animated animate__fadeIn space-y-8">

          <div class="flex justify-center">
            <div class="flex flex-col items-center gap-2">
              <span class="text-xs uppercase font-bold text-gray-400 tracking-wider">Í≤åÏûÑ Î≥¥Îìú</span>
              <div id="game-grid" class="grid grid-cols-8 gap-1 p-3 bg-gray-100 rounded-xl border border-gray-200">
                <!-- 8x8 Grid Generated by JS -->
              </div>
            </div>
          </div>

          <div class="flex justify-center">
            <div class="w-full max-w-sm">
              <span class="block text-center text-xs uppercase font-bold text-gray-400 tracking-wider mb-2">ÏÇ¨Ïö© Í∞ÄÎä•Ìïú
                Î∏îÎ°ù</span>
              <div class="grid grid-cols-3 gap-4">
                <div id="piece-1"
                  class="aspect-square bg-gray-50 rounded-xl p-2 flex items-center justify-center border border-gray-100">
                </div>
                <div id="piece-2"
                  class="aspect-square bg-gray-50 rounded-xl p-2 flex items-center justify-center border border-gray-100">
                </div>
                <div id="piece-3"
                  class="aspect-square bg-gray-50 rounded-xl p-2 flex items-center justify-center border border-gray-100">
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>

      <!-- Divider -->
      <div class="h-px bg-gradient-to-r from-transparent via-gray-200 to-transparent w-full"></div>

      <!-- 2. Solutions Area -->
      <div id="solution-section" class="hidden bg-gray-50/50 p-6 md:p-10">
        <h3 class="text-center text-lg font-bold text-slate-800 mb-6">üèÜ Ï∂îÏ≤ú Ï†ÑÎûµ</h3>

        <!-- Steps Container (Horizontal Scroll on Mobile) -->
        <div class="flex md:grid md:grid-cols-3 gap-4 overflow-x-auto pb-6 snap-x snap-mandatory scrollbar-hide">

          <!-- Step 1 -->
          <div
            class="snap-center min-w-[260px] md:min-w-0 flex-1 bg-white rounded-2xl p-4 shadow-sm border border-gray-100">
            <div class="flex justify-between items-center mb-3">
              <span class="text-xs font-bold text-indigo-500 bg-indigo-50 px-2 py-1 rounded">1Îã®Í≥Ñ</span>
            </div>
            <div id="step-1-grid" class="grid grid-cols-8 gap-0.5 bg-gray-100 p-2 rounded-lg aspect-square"></div>
            <p id="step-1-desc" class="text-xs text-center text-gray-500 mt-2">Î∏îÎ°ù Î∞∞Ïπò...</p>
          </div>

          <!-- Step 2 -->
          <div
            class="snap-center min-w-[260px] md:min-w-0 flex-1 bg-white rounded-2xl p-4 shadow-sm border border-gray-100">
            <div class="flex justify-between items-center mb-3">
              <span class="text-xs font-bold text-indigo-500 bg-indigo-50 px-2 py-1 rounded">2Îã®Í≥Ñ</span>
            </div>
            <div id="step-2-grid" class="grid grid-cols-8 gap-0.5 bg-gray-100 p-2 rounded-lg aspect-square"></div>
            <p id="step-2-desc" class="text-xs text-center text-gray-500 mt-2">Îã§Ïùå Î∞∞Ïπò...</p>
          </div>

          <!-- Step 3 -->
          <div
            class="snap-center min-w-[260px] md:min-w-0 flex-1 bg-white rounded-2xl p-4 shadow-sm border border-gray-100">
            <div class="flex justify-between items-center mb-3">
              <span class="text-xs font-bold text-indigo-500 bg-indigo-50 px-2 py-1 rounded">3Îã®Í≥Ñ</span>
            </div>
            <div id="step-3-grid" class="grid grid-cols-8 gap-0.5 bg-gray-100 p-2 rounded-lg aspect-square"></div>
            <p id="step-3-desc" class="text-xs text-center text-gray-500 mt-2">ÎßàÏßÄÎßâ...</p>
          </div>

        </div>
      </div>

    </div>

    <div class="text-center mt-8 text-gray-400 text-sm">
      <p>Î™®Îì† Ï≤òÎ¶¨Îäî Î°úÏª¨ÏóêÏÑú ÏßÑÌñâÎê©ÎãàÎã§. Ïù¥ÎØ∏ÏßÄÎäî ÏÑúÎ≤ÑÎ°ú Ï†ÑÏÜ°ÎêòÏßÄ ÏïäÏäµÎãàÎã§.</p>
    </div>

  </main>

  <!-- Hidden Canvas for Processing -->
  <canvas id="cv-canvas" class="hidden"></canvas>

  <!-- LOGIC SCRIPT -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // --- CONFIG & STATE ---
      const ROWS = 8;
      const COLS = 8;

      // --- DOM ELEMENTS ---
      const fileInput = document.getElementById('image-upload');
      const previewImg = document.getElementById('preview-img');
      const uploadPlaceholder = document.getElementById('upload-placeholder');
      const loadingOverlay = document.getElementById('loading-overlay');
      const analysisResults = document.getElementById('analysis-results');
      const solutionSection = document.getElementById('solution-section');

      const gameGridEl = document.getElementById('game-grid');
      const pieceEls = [
        document.getElementById('piece-1'),
        document.getElementById('piece-2'),
        document.getElementById('piece-3')
      ];

      // --- SOLVER ENGINE ---

      function createBoard() {
        return Array(ROWS).fill().map(() => Array(COLS).fill(0));
      }

      // Logic: Can we place a piece at (r,c)?
      function canPlace(board, piece, r, c) {
        for (let i = 0; i < piece.shape.length; i++) {
          for (let j = 0; j < piece.shape[0].length; j++) {
            if (piece.shape[i][j] === 1) {
              // Check boundaries
              if (r + i >= ROWS || c + j >= COLS) return false;
              // Check overlap
              if (board[r + i][c + j] === 1) return false;
            }
          }
        }
        return true;
      }

      // Logic: Place piece and calculate cleared lines
      function placePiece(board, piece, r, c) {
        // Deep copy board
        const newBoard = board.map(row => [...row]);

        // Place blocks
        for (let i = 0; i < piece.shape.length; i++) {
          for (let j = 0; j < piece.shape[0].length; j++) {
            if (piece.shape[i][j] === 1) {
              newBoard[r + i][c + j] = 1;
            }
          }
        }

        // Detect Lines
        const rowsToClear = [];
        const colsToClear = [];

        for (let i = 0; i < ROWS; i++) {
          if (newBoard[i].every(val => val === 1)) rowsToClear.push(i);
        }
        for (let j = 0; j < COLS; j++) {
          if (newBoard.every(row => row[j] === 1)) colsToClear.push(j);
        }

        // Clear Lines
        rowsToClear.forEach(rowIndex => {
          newBoard[rowIndex] = Array(COLS).fill(0);
        });
        colsToClear.forEach(colIndex => {
          for (let i = 0; i < ROWS; i++) newBoard[i][colIndex] = 0;
        });

        const linesCleared = rowsToClear.length + colsToClear.length;
        return { board: newBoard, linesCleared };
      }

      // Logic: Evaluate board state (Heuristic)
      function evaluateBoard(board) {
        let emptySpaces = 0;
        let fragmentation = 0; // Penalty for isolated spaces

        for (let i = 0; i < ROWS; i++) {
          for (let j = 0; j < COLS; j++) {
            if (board[i][j] === 0) {
              emptySpaces++;
              // Simple fragmentation check
              let neighbors = 0;
              if (i > 0 && board[i - 1][j] === 0) neighbors++;
              if (i < ROWS - 1 && board[i + 1][j] === 0) neighbors++;
              if (j > 0 && board[i][j - 1] === 0) neighbors++;
              if (j < COLS - 1 && board[i][j + 1] === 0) neighbors++;

              if (neighbors === 0) fragmentation += 10;
              else if (neighbors < 2) fragmentation += 5;
            }
          }
        }
        // We want more empty spaces, less fragmentation
        return (emptySpaces * 2) - fragmentation;
      }

      // Logic: Backtracking Solver
      function solve(board, pieces) {
        // Get all permutations of pieces order
        const perms = getPermutations(pieces.map((p, idx) => ({ ...p, originalIdx: idx })));

        let bestScenario = null;
        let maxScore = -Infinity;

        for (const orderedPieces of perms) {
          const result = backtrack(board, orderedPieces, [], 0);
          if (result.score > maxScore) {
            maxScore = result.score;
            bestScenario = result.sequence;
          }
        }

        return bestScenario || [];
      }

      function backtrack(currentBoard, remainingPieces, currentSequence, currentScore) {
        if (remainingPieces.length === 0) {
          return {
            score: currentScore + evaluateBoard(currentBoard),
            sequence: currentSequence
          };
        }

        const currentPiece = remainingPieces[0];
        let bestLocal = { score: -Infinity, sequence: [] };
        let placedAtLeastOnce = false;

        // Try all locations
        // Optimization: The grid is 8x8, pieces are small. Brute force is fast enough for depth 3.
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (canPlace(currentBoard, currentPiece, r, c)) {
              placedAtLeastOnce = true;

              const { board: nextBoard, linesCleared } = placePiece(currentBoard, currentPiece, r, c);

              // Score for this move
              let moveScore = linesCleared > 0 ? (linesCleared * 100 * Math.pow(1.5, linesCleared)) : 0;

              const result = backtrack(nextBoard, remainingPieces.slice(1), [...currentSequence, {
                pieceId: currentPiece.originalIdx,
                shape: currentPiece.shape,
                r: r,
                c: c,
                cleared: linesCleared
              }], currentScore + moveScore);

              if (result.score > bestLocal.score) {
                bestLocal = result;
              }
            }
          }
        }

        if (!placedAtLeastOnce) {
          // Cannot place piece - Game Over for this path
          return { score: -1000, sequence: currentSequence };
        }

        return bestLocal;
      }

      function getPermutations(arr) {
        if (arr.length <= 1) return [arr];
        return arr.flatMap((v, i) => getPermutations(arr.filter((_, j) => i !== j)).map(p => [v, ...p]));
      }


      // --- IMAGE PROCESSING (V15: Adaptive Grid & Simplified Contrast) ---
      // --- IMAGE PROCESSING (V16: Robust Grid & Cluster Blocks) ---
      async function analyzeImage(file) {
        return new Promise(resolve => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.getElementById('cv-canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            const STANDARD_WIDTH = 400;
            const scale = STANDARD_WIDTH / img.width;
            canvas.width = STANDARD_WIDTH;
            canvas.height = img.height * scale;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const width = canvas.width;
            const height = canvas.height;
            const imgData = ctx.getImageData(0, 0, width, height);
            const pixels = imgData.data;

            // Helper: Get Pixel Color
            function getPixel(x, y) {
              x = Math.floor(x);
              y = Math.floor(y);
              if (x < 0) x = 0; if (x >= width) x = width - 1;
              if (y < 0) y = 0; if (y >= height) y = height - 1;
              const i = (y * width + x) * 4;
              return { r: pixels[i], g: pixels[i + 1], b: pixels[i + 2] };
            }

            // Helper: Color Distance
            function colorDist(c1, c2) {
              return Math.abs(c1.r - c2.r) + Math.abs(c1.g - c2.g) + Math.abs(c1.b - c2.b);
            }

            // === STEP 1: BOARD DETECTION (Vertical Edges) ===
            const vProfile = new Float32Array(width).fill(0);
            const scanTop = Math.floor(height * 0.2);
            const scanBottom = Math.floor(height * 0.5);

            for (let y = scanTop; y < scanBottom; y += 4) {
              for (let x = 10; x < width - 10; x++) {
                const diff = colorDist(getPixel(x - 2, y), getPixel(x + 2, y));
                if (diff > 30) vProfile[x] += diff;
              }
            }

            let maxV = 0;
            for (let x = 0; x < width; x++) if (vProfile[x] > maxV) maxV = vProfile[x];
            const vThresh = maxV * 0.15;

            let boardLeft = 20, boardRight = width - 20;
            for (let x = 20; x < width / 2; x++) {
              if (vProfile[x] > vThresh) { boardLeft = x; break; }
            }
            for (let x = width - 20; x > width / 2; x--) {
              if (vProfile[x] > vThresh) { boardRight = x; break; }
            }

            // Margin safety
            boardLeft += 2;
            boardRight -= 2;
            const boardWidth = boardRight - boardLeft;
            const cellSize = boardWidth / 8;

            // === STEP 2: VERTICAL GRID PROCESSING (Fix for Misalignment) ===
            // Instead of relying on horizontal lines (which confuses the indicator row),
            // we look for the "Vertical Grid Activity" over the expected board height.
            // The board is a square of size boardWidth.
            // Vertically, the real board has continuous grid lines/blocks. The indicator row is short.

            const vGridActivity = new Int32Array(height).fill(0);

            // Scan the 7 internal vertical grid lines
            for (let c = 1; c <= 7; c++) {
              const vx = Math.floor(boardLeft + c * cellSize);
              for (let y = Math.floor(height * 0.1); y < height * 0.8; y++) {
                // Check local vertical edge strength
                const d = colorDist(getPixel(vx - 1, y), getPixel(vx + 1, y));
                if (d > 25) vGridActivity[y]++;
              }
            }

            // Find window of size boardWidth with max sum of activity
            let bestTopY = Math.floor(height * 0.25);
            let maxActivity = -1;

            const minSearchY = Math.floor(height * 0.15);
            const maxSearchY = Math.floor(height * 0.55); // Board shouldn't start too low

            for (let y = minSearchY; y < maxSearchY; y += 2) {
              let currentActivity = 0;
              // Sum activity in the window [y, y + boardWidth]
              // Optimization: Moving window sum
              for (let k = 0; k < boardWidth; k += 4) { // Sampling every 4th pixel is enough estimate
                if (y + k < height) currentActivity += vGridActivity[y + k];
              }

              if (currentActivity > maxActivity) {
                maxActivity = currentActivity;
                bestTopY = y;
              }
            }

            const boardTop = bestTopY;
            const boardBottom = boardTop + boardWidth;

            // Debug Board Box
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = 3;
            ctx.strokeRect(boardLeft, boardTop, boardWidth, boardWidth);

            // === STEP 3: RECOGNIZE BOARD CONTENT (Relative Color) ===
            // Determine "Empty/Grid" color by sampling the grid intersections
            let gR = 0, gG = 0, gB = 0, gCount = 0;
            for (let r = 1; r <= 7; r++) {
              for (let c = 1; c <= 7; c++) {
                // Grid intersection
                const ix = boardLeft + c * cellSize;
                const iy = boardTop + r * cellSize;
                const p = getPixel(ix, iy);
                gR += p.r; gG += p.g; gB += p.b; gCount++;
              }
            }
            const bg = gCount > 0 ? { r: gR / gCount, g: gG / gCount, b: gB / gCount } : { r: 50, g: 50, b: 50 };

            const board = [];
            for (let r = 0; r < 8; r++) {
              const row = [];
              for (let c = 0; c < 8; c++) {
                const cx = boardLeft + c * cellSize + cellSize / 2;
                const cy = boardTop + r * cellSize + cellSize / 2;

                // Sample center 3x3 area
                let diffSum = 0;
                let sCount = 0;
                for (let dy = -1; dy <= 1; dy++) {
                  for (let dx = -1; dx <= 1; dx++) {
                    const p = getPixel(cx + dx, cy + dy);
                    diffSum += colorDist(p, bg);
                    sCount++;
                  }
                }
                const avgDiff = diffSum / sCount;

                // Threshold: If significantly different from grid background, it's a block
                const isFilled = avgDiff > 45; // Tuned threshold

                row.push(isFilled ? 1 : 0);

                if (isFilled) {
                  ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                  ctx.fillRect(cx - 6, cy - 6, 12, 12);
                }
              }
              board.push(row);
            }

            // === STEP 4: PIECE RECOGNITION (Clustering) ===
            const pieces = [];
            const pScanTop = boardBottom + 10;
            // Limit scan height to avoid ads at the bottom
            const pScanBot = Math.min(height - 5, pScanTop + boardWidth * 0.7);

            // 1. Determine local background color (Robust Sampling)
            // Sample 5 points horizontally across the top of the piece area
            const bgSamples = [];
            for (let i = 0; i <= 4; i++) {
              const sx = Math.floor(width * (0.1 + i * 0.2));
              bgSamples.push(getPixel(sx, pScanTop + 5));
            }
            bgSamples.sort((a, b) => (a.r + a.g + a.b) - (b.r + b.g + b.b));
            const pBg = bgSamples[2]; // Median

            // Debug Piece Detection Area
            ctx.strokeStyle = 'rgba(255, 0, 255, 0.5)';
            ctx.strokeRect(0, pScanTop, width, pScanBot - pScanTop);

            // 2. Scan for Non-Background Pixels (Binary Map)
            const xHistogram = new Int32Array(width).fill(0);
            for (let x = 0; x < width; x += 2) {
              let colHits = 0;
              for (let y = pScanTop; y < pScanBot; y += 2) {
                // Lower threshold slightly (25) to catch darker blocks
                if (colorDist(getPixel(x, y), pBg) > 25) {
                  colHits++;
                }
              }
              // Noise filter: a column needs > 2 pixels to be part of a piece
              if (colHits > 2) xHistogram[x] = colHits;
            }

            // 3. Find Horizontal Clusters (Pieces)
            const segments = [];
            let inSeg = false;
            let startX = 0;
            let gapCounter = 0;

            for (let x = 0; x < width; x += 2) {
              const hit = xHistogram[x] > 0;

              if (hit) {
                if (!inSeg) { inSeg = true; startX = x; }
                gapCounter = 0;
              } else {
                if (inSeg) {
                  gapCounter += 2;
                  // Allow larger intra-piece gaps, but split distinctive pieces
                  if (gapCounter > 15) {
                    inSeg = false;
                    if ((x - startX) > 15) { // Min Width
                      segments.push({ x1: startX, x2: x - gapCounter });
                    }
                  }
                }
              }
            }
            if (inSeg && (width - startX) > 15) segments.push({ x1: startX, x2: width });

            // 4. Process Segments (Sort by X position)
            const validSegments = segments.sort((a, b) => a.x1 - b.x1).slice(0, 3);

            validSegments.forEach(seg => {
              // Find exact bounds within segment
              let minX = seg.x2, maxX = seg.x1, minY = pScanBot, maxY = pScanTop;

              for (let x = seg.x1; x <= seg.x2; x += 2) {
                for (let y = pScanTop; y < pScanBot; y += 2) {
                  if (colorDist(getPixel(x, y), pBg) > 25) {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                  }
                }
              }

              // Expand slightly
              minX -= 2; maxX += 2; minY -= 2; maxY += 2;
              // Safety check
              if (minX < 0) minX = 0; if (maxX > width) maxX = width;

              const w = maxX - minX;
              const h = maxY - minY;

              if (w < 8 || h < 8) return; // Too small

              // Debug Box
              ctx.strokeStyle = 'cyan';
              ctx.lineWidth = 2;
              ctx.strokeRect(minX, minY, w, h);

              // Grid Fit Logic
              let bestR = 1, bestC = 1, minDiff = 9999;
              for (let c = 1; c <= 5; c++) {
                for (let r = 1; r <= 5; r++) {
                  const cw = w / c;
                  const ch = h / r;
                  const diff = Math.abs(cw - ch);
                  if (cw < 10 || ch < 10) continue;
                  if (diff < minDiff) { minDiff = diff; bestR = r; bestC = c; }
                }
              }

              const finalCW = w / bestC;
              const finalCH = h / bestR;

              // Build Shape
              const shapeRaw = [];
              for (let r = 0; r < bestR; r++) {
                const row = [];
                for (let c = 0; c < bestC; c++) {
                  const tx = Math.floor(minX + c * finalCW + finalCW / 2);
                  const ty = Math.floor(minY + r * finalCH + finalCH / 2);

                  // Sample 3x3
                  let solid = 0;
                  for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                      if (colorDist(getPixel(tx + dx, ty + dy), pBg) > 25) solid++;
                    }
                  }
                  row.push(solid >= 4 ? 1 : 0);

                  if (solid >= 4) {
                    ctx.fillStyle = 'blue';
                    ctx.fillRect(tx - 2, ty - 2, 4, 4);
                  }
                }
                shapeRaw.push(row);
              }

              // Center in 5x5
              const shape = Array(5).fill().map(() => Array(5).fill(0));
              const rOff = Math.floor((5 - bestR) / 2);
              const cOff = Math.floor((5 - bestC) / 2);

              for (let r = 0; r < bestR; r++) {
                for (let c = 0; c < bestC; c++) {
                  shape[rOff + r][cOff + c] = shapeRaw[r][c];
                }
              }
              pieces.push({ shape: trimShape(shape) }); // Using existing trimShape
            });

            // Fill missing pieces
            while (pieces.length < 3) {
              pieces.push({ shape: [[1]] }); // Safe dummy
            }

            const previewImg = document.getElementById('preview-img');
            previewImg.src = canvas.toDataURL();

            resolve({ board, pieces });
          };
          img.src = URL.createObjectURL(file);
        });
      }

      function trimShape(shape) {
        let minR = 5, maxR = -1, minC = 5, maxC = -1;
        for (let r = 0; r < 5; r++) {
          for (let c = 0; c < 5; c++) {
            if (shape[r][c] === 1) {
              if (r < minR) minR = r;
              if (r > maxR) maxR = r;
              if (c < minC) minC = c;
              if (c > maxC) maxC = c;
            }
          }
        }
        if (maxR === -1) return [[1]];

        const newRows = maxR - minR + 1;
        const newCols = maxC - minC + 1;
        const cropped = Array(newRows).fill().map(() => Array(newCols).fill(0));

        for (let r = 0; r < newRows; r++) {
          for (let c = 0; c < newCols; c++) {
            cropped[r][c] = shape[minR + r][minC + c];
          }
        }
        return cropped;
      }


      // --- UI DRAWING ---
      function renderCell(container, isFilled, colorClass = 'bg-indigo-500') {
        const div = document.createElement('div');
        // Base styles
        div.className = `rounded-sm w-full h-full transition-all duration-300 ${isFilled ? colorClass + ' shadow-sm' : 'bg-gray-200/50'}`;
        container.appendChild(div);
      }

      function drawGrid(containerEl, boardData, rows = 8, cols = 8) {
        containerEl.innerHTML = '';
        containerEl.style.display = 'grid';
        containerEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        containerEl.style.width = '280px';
        containerEl.style.height = '280px';
        containerEl.style.gap = '3px';

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const isFilled = boardData[r][c] === 1;
            const div = document.createElement('div');
            div.className = `rounded-sm ${isFilled ? 'bg-indigo-500 shadow-sm' : 'bg-gray-200/50'}`;
            div.style.aspectRatio = '1';
            containerEl.appendChild(div);
          }
        }
      }

      function drawPiece(containerEl, shape) {
        const pRows = shape.length;
        const pCols = shape[0].length;
        containerEl.innerHTML = '';
        containerEl.style.display = 'grid';
        containerEl.style.gridTemplateColumns = `repeat(${pCols}, 1fr)`;
        containerEl.style.width = `${pCols * 24}px`;
        containerEl.style.gap = '2px';

        for (let r = 0; r < pRows; r++) {
          for (let c = 0; c < pCols; c++) {
            const isFilled = shape[r][c] === 1;
            const div = document.createElement('div');
            div.style.width = '20px';
            div.style.height = '20px';
            div.className = `rounded-sm ${isFilled ? 'bg-indigo-500 shadow-sm' : 'bg-transparent'}`;
            containerEl.appendChild(div);
          }
        }
      }

      function drawSolutionStep(stepIndex, moveData, currentBoardState) {
        const container = document.getElementById(`step-${stepIndex + 1}-grid`);
        const label = document.getElementById(`step-${stepIndex + 1}-desc`);
        if (!moveData) return;

        container.innerHTML = '';
        // We need to show the board state + the new piece in a different color

        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            let isBoardBlock = currentBoardState[r][c] === 1;
            let isNewPieceBlock = false;

            // Check if coordinate matches the placement
            if (r >= moveData.r && r < moveData.r + moveData.shape.length &&
              c >= moveData.c && c < moveData.c + moveData.shape[0].length) {
              if (moveData.shape[r - moveData.r][c - moveData.c] === 1) {
                isNewPieceBlock = true;
              }
            }

            const div = document.createElement('div');
            if (isNewPieceBlock) {
              div.className = `w-full h-full rounded-sm bg-green-500 animate-pulse shadow-sm z-10`;
            } else if (isBoardBlock) {
              div.className = `w-full h-full rounded-sm bg-indigo-300`;
            } else {
              div.className = `w-full h-full rounded-sm bg-white border border-gray-100`;
            }
            container.appendChild(div);
          }
        }

        label.innerText = `${moveData.pieceId + 1}Î≤à Î∏îÎ°ùÏùÑ (${moveData.r + 1}, ${moveData.c + 1})Ïóê Î∞∞Ïπò`;
      }


      // --- EVENT LISTENERS ---

      fileInput.addEventListener('change', async (e) => {
        if (!e.target.files || !e.target.files[0]) return;
        const file = e.target.files[0];

        // 1. UI Updates
        const reader = new FileReader();
        reader.onload = (ev) => {
          previewImg.src = ev.target.result;
          previewImg.classList.remove('hidden');
          uploadPlaceholder.classList.add('hidden');
        };
        reader.readAsDataURL(file);

        loadingOverlay.classList.remove('hidden');
        analysisResults.classList.add('hidden');
        solutionSection.classList.add('hidden');

        try {
          // 2. Analyze
          const gameData = await analyzeImage(file);

          // 3. Render Detected State
          drawGrid(gameGridEl, gameData.board);
          gameData.pieces.forEach((p, idx) => {
            drawPiece(pieceEls[idx], p.shape);
          });

          // 4. Solve
          const solutionMoves = solve(gameData.board, gameData.pieces);

          // 5. Render Solution Steps
          let mockBoard = gameData.board.map(r => [...r]);

          solutionMoves.forEach((move, idx) => {
            if (idx < 3) {
              drawSolutionStep(idx, move, mockBoard);
              // Advance board state
              const res = placePiece(mockBoard, { shape: move.shape }, move.r, move.c);
              mockBoard = res.board;
            }
          });

          // 6. Reveal
          loadingOverlay.classList.add('hidden');
          analysisResults.classList.remove('hidden');
          solutionSection.classList.remove('hidden');

          // Scroll to results
          analysisResults.scrollIntoView({ behavior: 'smooth', block: 'start' });

        } catch (err) {
          console.error("Solver Error:", err);
          alert("Something went wrong analyzing the board. Please try again.");
          loadingOverlay.classList.add('hidden');
        }

      });

    });
  </script>
</body>

</html>
